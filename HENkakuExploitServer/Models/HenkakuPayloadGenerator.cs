using System;
using System.Collections.Generic;
using System.Linq;
using System.IO;
using System.Web;

namespace HENkakuExploitServer.Models
{
	public static class HenkakuPayloadGenerator
	{
		private static byte[] basePayload = null;
		private static string basePayloadFile = "base_payload.bin";
		private static string offsetsFile = "offsets.txt";
		private static Dictionary<int, int> fileOffsetToAddress = null;


		public static byte[] GeneratePayload(UInt32 a1, UInt32 a2, UInt32 a3, UInt32 a4, UInt32 a5, UInt32 a6, UInt32 a7)
		{
			if (basePayload == null)
			{
				basePayload = File.ReadAllBytes(Path.Combine(HttpRuntime.AppDomainAppPath, basePayloadFile));

				if (basePayload.Length != 91444)
					throw new InvalidOperationException("Base payload file not valid");
			}

			if (fileOffsetToAddress == null)
			{
				var offsetsText = File.ReadAllText(Path.Combine(HttpRuntime.AppDomainAppPath, offsetsFile));
				fileOffsetToAddress = new Dictionary<int, int>();

				var offsets = offsetsText.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries);
				for (int i = 0; i < offsets.Length; i++)
				{
					var offsetParts = offsets[i].Split(':');
					var addressIndex = 0;
					switch (offsetParts[1])
					{
						case "a1":
							addressIndex = 0;
							break;
						case "a2":
							addressIndex = 1;
							break;
						case "a3":
							addressIndex = 2;
							break;
						case "a4":
							addressIndex = 3;
							break;
						case "a5":
							addressIndex = 4;
							break;
						case "a6":
							addressIndex = 5;
							break;
						case "a7":
							addressIndex = 6;
							break;
					}
					fileOffsetToAddress.Add(Int32.Parse(offsetParts[0], System.Globalization.NumberStyles.AllowHexSpecifier), addressIndex);
				}
			}


			var list = new List<UInt32>();

			var newPayload = new byte[basePayload.Length];

			for (int i = 0; i < basePayload.Length; i += 4)
			{
				System.UInt32 offset = (UInt32)(basePayload[i] | basePayload[i + 1] << 8 | basePayload[i + 2] << 16 | basePayload[i + 3] << 24);

				if (fileOffsetToAddress.ContainsKey(i))
				{
					UInt32 newValue = 0;

					switch (fileOffsetToAddress[i])
					{
						case 0:
							newValue = a1 + offset;
							break;
						case 1:
							newValue = a2 + offset;
							break;
						case 2:
							newValue = a3 + offset;
							break;
						case 3:
							newValue = a4 + offset;
							break;
						case 4:
							newValue = a5 + offset;
							break;
						case 5:
							newValue = a6 + offset;
							break;
						case 6:
							newValue = a7 + offset;
							break;
					}

					newPayload[i] = (byte)(newValue & 0xff);
					newPayload[i + 1] = (byte)(newValue >> 8 & 0xff);
					newPayload[i + 2] = (byte)(newValue >> 16 & 0xff);
					newPayload[i + 3] = (byte)(newValue >> 24 & 0xff);
				}
				else
				{
					newPayload[i] = basePayload[i];
					newPayload[i + 1] = basePayload[i + 1];
					newPayload[i + 2] = basePayload[i + 2];
					newPayload[i + 3] = basePayload[i + 3];
				}
			}

			return newPayload;
		}
	}
}